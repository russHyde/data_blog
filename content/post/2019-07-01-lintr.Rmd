---
title: "`lintr`"
author: Russ Hyde
date: '2019-07-01'
slug: lintr
categories:
  - R
tags:
  - code-analysis
  - rstats
lastmod: '2019-07-01T18:25:47+01:00'
layout: post
type: post
highlight: no
---

**Lint is the fluff on your clothes. Aside from all that fluff, you look fine.**

[`lintr`](https://github.com/jimhester/lintr) (Author: Jim Hester) compares the
code in your files / packages against a style-guide. This helps ensure your
source code looks pretty consistent across your package(s).

Why is that useful?

It might not be. I couldn't find many objective studies of code readability
amongst the thousands of opinion pieces that are online, so I can't tell you
whether consistent styling is all _that_ valuable. Hell, writing R code may
dull your consistency desires: in a typical script I might have a
`suppressPackageStartupMessages`, a `file.exists()`, a `read_tsv()`, and a
`Heatmap()` all present. It might be nice if things were less surprising, and
it always feels nicer to contribute to projects that are neatly formatted.

But this is your project we're talking about. If you like your lines to be
at-most 100 characters wide, get in early and specify that the lines must be
at-most 100 characters wide. Similarly, if you like your object names to be
`snake_case`, write up a `.lintr` file that ensures any contributors have to
follow in your wake.

`lintr` can be used on individual files (`.R`, `.Rmd`, `.Rnw` etc), directories
or packages. _Rstudio_, _vim_, _atom_ etc can be integrated with `lintr` (see
the details at the `lintr` [github page](https://github.com/jimhester/lintr)).
For example, through integration with _syntastic_, _vim_ can run `lintr`
whenever you save a file, and if you run `lintr` within _Rstudio_, any lints
that are identified are put into the `Markers` pane.

To run `lintr` call:

```
lintr::lint(some_file)
```

```{r, echo = FALSE}
code <- "# -- My important script
abc <- 123

def = 456

c(0);

# some unparseable code:
FALSE <- TRUE

# some <- \"commented code\"

ghi = 789

my_unportable_file <- \"~/hello/world\"

snakeCase <- runif(10)

dotty.variable.name <- Sys.time()

my_s3_class.print <- print

# Right assignment isn't caught yet
\"A most perilous\" -> assignment
"

f <- tempfile(pattern = "", fileext = ".R")
cat(code, file = f)
```

Some example code, stored in a temporary file that we can refer to using `f`

```{r, code = readLines(f), eval = FALSE}
```

We can now run `lintr` on that script, with the default choice of linting
functions, and view the style-issues that are returned.

```{r, comment = ""}
lintr::lint(filename = f)
```

```{r}
# FYI:
installed.packages()["lintr", "Version"]
```

<!--
Simple example:

- New project
- add `my_script.R`
- define a few functions, trailing curly braces and absolute paths as examples
- since absolute paths is not a default linter in lintr::1.0.3, add this to
  the default_linters
- show how to drop lines from linting using `# nolint start` / `# nolint end`
- show how to define a linter
-->

<!--
Code smells that can be detected with `lintr`

- Commented-out code
- Inconsistency
- Clutter / Dead Code (via codetools::checkUsage())

But it can't prevent you choosing mysterious names

Architectural properties that `lintr` shines a light on:

- readability
    - keep those lines narrow

- security
    - catch unsafe extractions with `extraction_operator_linter`
    - prevent use of undesirable functions/operators/symbols

- deployability / usability
    - catch any non-portable paths using `absolute_path_linter` / `nonportable_path_linter`
-->
